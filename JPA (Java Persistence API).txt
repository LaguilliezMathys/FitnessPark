JPA (Java Persistence API)
Étapes réalisées
1) Pré-requis & base de données
1. Vérifier la version de Java.
2. Télécharger/dézipper les ressources (MariaDB portable + fichiers SQL/XML) et organiser l’arborescence
de travail.
3. Démarrer MariaDB puis ouvrir le client MySQL.
4. Créer et initialiser la base springdb avec le script personne-step1.sql.
2) Mise en place du projet Maven
1. Créer un projet Maven demojpa (org : fr.iut).
2. Ajouter les dépendances nécessaires dans pom.xml.
3. Lancer un main “Hello World” pour valider l’environnement.
3) Première entité JPA : Personne
1. Créer le package fr.iut.entity.
2. Créer l’entité Personne avec ses champs + constructeur(s) + getters/setters.
3. Ajouter un toString() (pour afficher les entités lors des tests).
4) Configuration JPA : persistence.xml
1. Créer src/main/resources/META-INF/persistence.xml.
2. Renseigner :
le nom du persistence-unit (dbspring)
les paramètres JDBC (url, user, password)
la classe d’entité (ou vérifier la détection automatique selon la version)
5) CRUD avec EntityManager
1. Créer EntityManagerFactory, EntityManager, EntityTransaction.
2. Lire une liste de Personne via une requête JPQL (FROM Personne).
3. Ajouter progressivement : persist (CREATE), find (READ), update, remove (DELETE).
4. Valider l’exécution du/des main.
6) Relation entre entités
1. One-to-One entre Personne et Service (chef de service).
fichier SQL : personne-step2.sql
entités : Personne, Service
2. One-to-Many / Many-to-One entre Societe et Service.
fichier SQL : personne-step3.sql
entités : Societe, Service
0-jpa-memo.md 2026-01-27
2 / 3
3. Many-to-Many entre Article et Categorie.
fichier SQL : articles.sql
entités : Article, Categorie
À retenir
Commandes & SQL
Vérifier Java :
java --version
MariaDB portable :
start-server.bat
mysql-client.bat
SQL de base :
CREATE DATABASE springdb;
USE springdb;
SOURCE personne-step1.sql; (puis step2/step3/articles selon la partie)
SHOW TABLES; / DESCRIBE personne; / SELECT * FROM personne;
Classes / API JPA
EntityManagerFactory factory =
Persistence.createEntityManagerFactory("dbspring");
EntityManager manager = factory.createEntityManager();
EntityTransaction tx = manager.getTransaction();
CRUD :
Create : tx.begin(); manager.persist(obj); tx.commit();
Read : manager.find(Classe.class, id)
Query : manager.createQuery("FROM Personne", Personne.class)
Delete : manager.remove(obj)
Bon réflexe : fermer manager.close() et factory.close().
Annotations JPA vues
Entité simple
@Entity
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY) (auto-increment)
One-to-One (Service ↔ Personne)
Côté Service (propriétaire) :
@OneToOne
@JoinColumn(name = "id_chef")
Réciprocité côté Personne :
@OneToOne(mappedBy = "chef")
Important : si on veut la relation dispo tout de suite en mémoire, il faut souvent setter les 2 côtés.
0-jpa-memo.md 2026-01-27
3 / 3
One-to-Many / Many-to-One (Societe ↔ Service)
Dans Societe : @OneToMany(mappedBy = "societe")
Dans Service :
@ManyToOne
@JoinColumn(name = "id_societe")
Important : pour enregistrer correctement, on positionne au minimum le côté propriétaire
(Service.setSociete(...)).
Many-to-Many (Article ↔ Categorie)
Dans Categorie (propriétaire) :
@ManyToMany
@JoinTable(name = "Article_Categorie", joinColumns = ..., inverseJoinColumns
= ...)
Dans Article : @ManyToMany(mappedBy = "articles")
Attention : toString() peut provoquer une boucle infinie si on affiche les deux côtés.
Config / fichiers
Chemin obligatoire : src/main/resources/META-INF/persistence.xml
Élément clé : <persistence-unit name="dbspring"> ... </persistence-unit>
Paramètres JDBC typiques (MariaDB local) :
jdbc:mariadb://localhost/springdb
user/pass : root / root


1 - Init projet Spring Boot (mvcshop)
Étapes réalisées
0) Ressources & base de données
1. Récupérer sur Moodle le zip "TP Spring (ressources)" (image + application.properties
d’exemple).
2. Démarrer MariaDB (serveur déjà vu en TD JPA).
3. Prévoir une nouvelle base (et donc de nouvelles tables) pour ce projet.
1) Création du projet avec Spring Initializr
1. (VSCode) Installer l’extension Spring Boot Extension Pack.
2. Sur start.spring.io :
Project : Maven
Java : 17 ou 21
Packaging : Jar
Group : fr.iut
Artifact : mvcshop
Dependencies :
Spring Web
Spring Data JPA
Thymeleaf
MariaDB Driver
3. Télécharger (Generate), dézipper, puis ouvrir le dossier projet (celui qui contient pom.xml).
2) Configuration application.properties
1. Ouvrir src/main/resources/application.properties.
2. Renseigner :
server.port=8086
spring.datasource.url=jdbc:mariadb://localhost:3306/<base>
spring.datasource.username=<user>
spring.datasource.password=<pwd>
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
3) Page d’accueil (MVC + Thymeleaf)
1. Créer un package controller.
2. Créer HomeController : mapping GET / → vue home.
3. Créer src/main/resources/templates/home.html.
4. Inclure via CDN :
1-init-projet-memo.md 2026-01-27
2 / 2
Bootstrap CSS
Bootswatch (thème au choix)
Font Awesome
Bootstrap bundle JS
5. (Rappel) Utiliser Emmet pour aller vite : !, div.container.mt-5, h1.
4) Lancement / arrêt de l’application
Tester au moins une fois les 3 méthodes :
Terminal : ./mvnw spring-boot:run
VSCode : Spring Boot Dashboard → Run
Dans MvcshopApplication.java : lancer le main
Accès : http://localhost:8086. Arrêt : Ctrl+C.
5) (Option) Premier commit Git
git init
git add .
git commit -m "Init projet et page d'accueil"
À retenir
Fichiers & emplacements
src/main/resources/application.properties
src/main/resources/templates/home.html
src/main/java/.../controller/HomeController.java
Annotations / concepts
@Controller
@GetMapping("/")
Thymeleaf : la méthode retourne le nom de la vue ("home") → home.html dans templates/
Paramètres Spring Boot utiles
server.port
spring.datasource.*
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
Dépannage express
Vérifier MariaDB démarré + URL/user/pwd corrects.
Si port occupé → changer server.port.
Si erreur Thymeleaf → vérifier home.html dans templates + nom exact.
Si dépendances → ./mvnw clean install.


2 - Thymeleaf (templates, fragments, boucle)
Étapes réalisées
1) Template général avec fragments
1. Créer src/main/resources/templates/_layout.html.
2. Définir 2 fragments :
header(title, links, scripts) (avec paramètres)
menu (sans paramètre)
3. Mettre dans le header :
imports Bootstrap / Bootswatch / Font Awesome / JS
favicon shop.png
4. Copier shop.png dans src/main/resources/static/.
2) Adapter la page d’accueil pour réutiliser le layout
1. Modifier home.html pour :
remplacer le <head> par le fragment header
remplacer le <nav> par le fragment menu
3) Créer la page CGV + démo de boucle
1. Créer src/main/resources/templates/cgv.html.
2. Réutiliser le layout (header + menu).
3. Générer une grille de cartes Bootstrap avec une boucle Thymeleaf.
4. Ajouter la route dans HomeController : GET /cgv → vue cgv.
4) Test
Lancer l’application et naviguer :
/ (Accueil)
/cgv (CGV)
À retenir
Fragments Thymeleaf
Déclarer un fragment :
th:fragment="nom(...)"
Inclure/remplacer un fragment :
th:replace="~{ _layout :: header(...) }"
th:replace="~{ _layout :: menu }"
Passer des “paramètres” à un fragment :
ex. header(~{::title}, _, _)
URLs (liens & ressources)
2-thymeleaf-memo.md 2026-01-27
2 / 2
URL Thymeleaf : th:href="@{/cgv}"
Ressource statique (favicon/image) : th:href="@{shop.png}"
Boucle
Boucle : th:each="i : ${#numbers.sequence(1, 9)}"
Affichage d’une valeur dans le HTML : [[${i}]]
Conteneur “neutre” : th:block
Fichiers / emplacements
Layout : templates/_layout.html
Pages : templates/home.html, templates/cgv.html
Statique : static/shop.png
Controller
@GetMapping("/cgv")
Retourner le nom de vue : return "cgv";
Pièges fréquents
Nom exact des vues : cgv ↔ cgv.html (dans templates).
Ne pas mélanger href="/cgv" et th:href="@{/cgv}" si l’app n’est pas à la racine.


3 - Entities JPA + Repository + Liste Thymeleaf
(Produit)
Étapes réalisées
1) Créer l’entité Produit
1. Créer le package model.
2. Créer la classe Produit : id, designation, prix, quantite.
3. Ajouter : constructeur vide (obligatoire JPA) + constructeur paramétré + getters/setters.
2) Créer le repository Spring Data
1. Créer le package repository.
2. Créer l’interface ProduitRepository extends JpaRepository<Produit, Long>.
3) Initialiser des données au démarrage
1. Dans la classe ...Application (celle avec @SpringBootApplication) :
2. Ajouter un @Bean CommandLineRunner qui :
fait plusieurs repository.save(new Produit(...))
affiche repository.findAll() dans la console.
4) Contrôleur MVC pour lister les produits
1. Créer ProduitController dans controller.
2. Injection du ProduitRepository (constructeur).
3. Route GET /produits :
ajoute produits au Model
retourne la vue produits.
5) Vue Thymeleaf produits.html
1. Créer templates/produits.html.
2. Réutiliser les fragments :
header + menu depuis _layout.html.
3. Afficher la liste avec :
un tableau Bootstrap
une boucle th:each.
4. Formatage et conditions :
affichage du prix formaté
quantité : “non disponible” si <= 0.
6) DevTools
1. Ajouter la dépendance spring-boot-devtools dans pom.xml.
3-entity-memo.md 2026-01-30
2 / 2
À retenir
Annotations JPA
@Entity
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
Spring Data JPA
JpaRepository<Produit, Long> fournit déjà :
save(...), findAll(), findById(...), deleteById(...), …
Initialisation au démarrage
@Bean + CommandLineRunner → exécute du code après le démarrage de Spring Boot.
MVC + Thymeleaf
Controller :
@Controller
@GetMapping("/produits")
model.addAttribute("produits", repository.findAll())
return "produits";
Vue :
Boucle : th:each="prod : ${produits}"
Texte : th:text="${prod.designation}"
Condition : th:text="${prod.quantite<=0 ? 'non disponible' : prod.quantite}"
Format nombre : #numbers.formatDecimal(...)
Fichiers / emplacements
Entité : src/main/java/.../model/Produit.java
Repository : src/main/java/.../repository/ProduitRepository.java
Controller : src/main/java/.../controller/ProduitController.java
Template : src/main/resources/templates/produits.html
Dépendance : pom.xml
Pièges fréquents
Oublier le constructeur vide dans l’entité.
Oublier de passer la liste dans le Model (sinon ${produits} est vide/undefined).
Confondre nom de vue "produits" et fichier produits.html.
Attention aux boucles infinies dans toString() si vous affichez des relations bidirectionnelles (plus tard).


4 - Pagination Spring Data + Thymeleaf (liste produits)
Étapes réalisées
1) Activer la pagination côté repository
Rien à changer si ProduitRepository extends JpaRepository<Produit, Long> :
JpaRepository inclut déjà la pagination.
On utilisera : findAll(Pageable pageable).
2) Adapter le contrôleur /produits
1. Modifier la méthode GET /produits pour accepter 2 paramètres d’URL :
p : numéro de page (0, 1, 2, …)
s : taille de page (nb d’éléments par page)
2. Créer un Pageable : PageRequest.of(p, s).
3. Récupérer une Page<Produit> via produitRepository.findAll(pageable).
4. Mettre dans le Model :
produits : page.getContent() (liste de la page)
page : l’objet Page (infos de pagination)
3) Afficher les contrôles de pagination dans produits.html
1. Garder l’affichage de la liste sur produits.
2. Ajouter un composant Bootstrap pagination :
bouton « précédent » désactivé si page.first
bouton « suivant » désactivé si page.last
liens vers chaque page : boucle sur 0..page.totalPages-1
3. Conserver la taille s dans les liens (th:href avec s=${page.size}).
4) Choisir le nombre de produits par page (select)
1. Ajouter un <form method="get"> avec un <select name="s">.
2. Soumission automatique : onchange="this.form.submit()".
3. (Option) Conserver la page courante avec un champ caché :
<input type="hidden" name="p" th:value="${page.number}" />
À retenir
Spring Data pagination
Pageable pageable = PageRequest.of(page, size);
Page<Produit> page = produitRepository.findAll(pageable);
page.getContent() : contenu de la page
page.getNumber() : page courante (commence à 0)
page.getSize() : taille de page
4-pagination-memo.md 2026-01-27
2 / 2
page.getTotalPages() : nb total de pages
page.isFirst() / page.isLast() (ou page.first / page.last en Thymeleaf)
Paramètres HTTP
@RequestParam(value="p", defaultValue="0") int page
@RequestParam(value="s", defaultValue="5") int size
Thymeleaf (liens)
Générer une URL avec paramètres :
th:href="@{/produits(s=${page.size}, p=${i})}"
Boucle sur pages :
th:each="i : ${#numbers.sequence(0, page.totalPages - 1)}"
Classe active :
th:classappend="${i == page.number} ? 'active' : ''"
Pièges fréquents
Les pages commencent à 0 (affichage utilisateur souvent i+1).
Toujours conserver s (size) dans les liens, sinon retour à la taille par défaut.
Si page.totalPages == 0, prévoir que la boucle de pagination n’affichera rien (liste vide).

5 - Paramètres de requête (recherche + pagination)
Étapes réalisées
1) Requête paramétrée dans ProduitRepository
1. Ajouter une méthode de recherche paginée.
2. Implémentation vue en TD : JPQL + @Query + ****@Param.
2) Contrôleur /produits : gérer le paramètre mc
1. Ajouter un paramètre d’URL mc (mot-clé) en plus de p et s.
2. Construire le Pageable (PageRequest.of(p, s)).
3. Si mc est vide → findAll(pageable).
4. Sinon → appel rechercher("%"+mc+"%", pageable).
5. Ajouter au Model :
produits (liste de la page)
page (objet Page)
motCle (pour ré-afficher la recherche dans le champ).
3) Vue produits.html : formulaire + pagination qui conserve mc
1. Ajouter un formulaire GET vers /produits avec un champ texte mc.
2. Pré-remplir le champ avec th:value="${motCle}".
3. Rendre la pagination conditionnelle : affichée seulement si page.totalPages > 1.
4. Ajouter mc=${motCle} dans tous les liens de pagination pour garder le filtre.
À retenir
Repository : requête paramétrée
Avec JPQL :
@Query("SELECT p FROM Produit p WHERE p.designation LIKE :x")
Page<Produit> rechercher(@Param("x") String mc, Pageable pageable);
Alternative Spring Data (souvent plus simple) :
Page<Produit> findByDesignationContaining(String designation, Pageable
pageable);
Contrôleur : paramètres HTTP
@RequestParam(name="mc", defaultValue="") String motCle
@RequestParam(value="p", defaultValue="0") int page
@RequestParam(value="s", defaultValue="5") int size
Pagination + filtre
5-requete-params-memo.md 2026-01-27
2 / 2
Toujours conserver mc et s dans les URLs :
th:href="@{/produits(s=${page.size}, p=${i}, mc=${motCle})}"
Thymeleaf : formulaire GET
th:action="@{/produits}" method="get"
Champ : name="mc" + th:value="${motCle}"
Pièges fréquents
Oublier les % autour du mot clé pour LIKE (sinon recherche “commence par”/“exacte” selon cas).
Oublier mc dans les liens de pagination → on perd le filtre en changeant de page.
(Optionnel) Conditionner l’affichage de la pagination : th:if="${page.totalPages > 1}".

6 - Suppression (DELETE) d’un produit
Étapes réalisées
1) Ajouter un bouton “supprimer” dans la liste
1. Dans produits.html, ajouter une colonne Action.
2. Pour chaque produit, afficher un bouton (icône poubelle) qui pointe vers une route de suppression, en
conservant les paramètres courants :
id (produit)
mc (mot-clé)
p (page)
s (size)
2) Ajouter une confirmation JavaScript
1. Dans le <head>, injecter un script spécifique à la page via le fragment header(..., ..., scripts).
2. Créer une fonction confDelProd(event) qui :
affiche confirm(...)
fait event.preventDefault() si l’utilisateur annule.
3. Appeler la fonction via onclick="confDelProd(event)" sur le lien/bouton.
3) Créer la route de suppression dans le contrôleur
1. Dans ProduitController, ajouter une méthode GET /produitDelete.
2. Supprimer via repoProd.deleteById(id).
3. Rediriger vers /produits en conservant p, s, mc avec RedirectAttributes.
À retenir
Vue (Thymeleaf)
Exemple de lien de suppression (avec conservation des paramètres) :
th:href="@{/produitDelete(id=${prod.id}, mc=${motCle}, p=${page.number},
s=${page.size})}"
Confirmation :
onclick="confDelProd(event)"
Script dans le head via le layout
Utiliser le fragment :
th:replace="~{ _layout :: header(~{::title}, _, ~{::script} ) }"
Contrôleur (redirection + paramètres)
Route : @RequestMapping(value="/produitDelete", method=RequestMethod.GET)
Redirection avec paramètres :
6-delete-memo.md 2026-01-27
2 / 2
RedirectAttributes.addAttribute("p", p)
RedirectAttributes.addAttribute("s", s)
RedirectAttributes.addAttribute("mc", mc)
return "redirect:/produits";
Pièges fréquents
Oublier mc, p, s dans le th:href → après suppression, on revient à la liste “par défaut”.
Attention aux noms de variables en Thymeleaf (prod vs produit) : être cohérent avec th:each.
(Bonnes pratiques) En vrai projet, une suppression devrait plutôt être faite en POST/DELETE (ici on fait
simple en GET pour le TD).


7 - Formulaire d’ajout / édition (Produit)
Étapes réalisées
1) Route GET /produitEdit (affichage du formulaire)
1. Ajouter dans ProduitController une route GET /produitEdit.
2. Paramètres gérés :
id (0 → ajout / >0 → édition)
mc, p, s (pour conserver le contexte liste)
3. Cas édition (id > 0) :
repoProd.findById(id)
si trouvé → model.addAttribute("produit", ...)
sinon → redirection /produits
4. Cas ajout (id == 0) :
model.addAttribute("produit", new Produit())
5. Ajouter au Model : p, s, mc.
6. Retourner la vue : "produitEdit".
2) Vue produitEdit.html (formulaire)
1. Créer templates/produitEdit.html.
2. Formulaire Thymeleaf :
th:action="@{/produitSave}"
th:object="${produit}"
method="post"
3. Champs cachés :
id via th:field="*{id}"
p, s, mc (pour retour à la liste)
4. Champs de saisie :
designation (text)
prix (number, step=".01")
quantite (number)
5. Boutons :
Valider (submit)
Annuler (lien vers /produits)
3) Route POST /produitSave (sauvegarde)
1. Ajouter une route POST /produitSave.
2. Recevoir : Produit produit + paramètres p, s, mc.
3. repoProd.save(produit) :
crée si id == null
modifie si id != null
4. Redirection vers /produits avec paramètres :
act=new ou act=mod
7-edit-memo.md 2026-01-27
2 / 3
id du produit
p, s, mc
4) Modifier la route GET /produits pour afficher un feedback
1. Ajouter des paramètres :
act ("new", "mod", "del" ou "")
id (produit concerné)
2. Si act vaut new ou mod et id>0 :
charger le produit et l’ajouter au Model.
3. Ajouter au Model : action (valeur de act) et éventuellement produit.
5) Modifier produits.html
1. Ajouter un bouton Ajouter un produit → /produitEdit (en conservant p, s, mc).
2. Ajouter un bouton Éditer (icône crayon) pour chaque ligne → /produitEdit?id=... (avec p, s, mc).
3. Ajouter des alertes Bootstrap dismissible :
succès création/modification (avec désignation + prix)
warning suppression (si action=='del')
À retenir
Contrôleur
Afficher un formulaire (GET) :
@GetMapping("/produitEdit")
model.addAttribute("produit", new Produit()) (ajout)
repoProd.findById(id) (édition)
Sauvegarder (POST) :
@PostMapping("/produitSave")
repoProd.save(produit)
return "redirect:/produits?..."
Thymeleaf : binding formulaire
Associer un objet : th:object="${produit}"
Binder un champ : th:field="*{designation}" (pareil pour prix, quantite, id)
Cacher l’id : <input type="hidden" th:field="*{id}" />
Garder le contexte (pagination + recherche)
Toujours transporter : p, s, mc.
En édition : champs hidden dans le formulaire.
En redirection : paramètres dans l’URL (ou via RedirectAttributes).
Feedback utilisateur (flash)
7-edit-memo.md 2026-01-27
3 / 3
Paramètres : act=new|mod|del + id.
Dans la vue liste :
th:if="${action=='new' || action=='mod'}" → alerte success
th:if="${action=='del'}" → alerte warning
Pièges fréquents
Oublier method="post" (sinon /produitSave ne match pas le @PostMapping).
Oublier les hidden p/s/mc → retour liste “réinitialisé”.
id :
null = nouveau produit
non null = édition (attention au defaultValue côté contrôleur)


8 - Validation (Bean Validation) sur le formulaire
Produit
Étapes réalisées
1) Ajouter la dépendance de validation
1. Vérifier / ajouter dans pom.xml :
spring-boot-starter-validation
2) Mettre des contraintes sur l’entité Produit
1. Importer les annotations de validation.
2. Annoter les champs :
designation : non nul + taille min/max
prix : non nul + minimum
quantite : non nul + minimum
3) Modifier la route POST /produitSave
1. Ajouter @Valid devant le paramètre Produit.
2. Ajouter BindingResult bindingResult juste après le Produit.
3. Si bindingResult.hasErrors() :
remettre p, s, mc dans le Model
retourner la vue produitEdit (sans sauvegarder)
4. Sinon : repoProd.save(produit) puis redirection vers /produits.
4) Afficher les erreurs dans produitEdit.html
1. Sur chaque champ :
ajouter une classe Bootstrap is-invalid si erreur
afficher le message d’erreur avec th:errors
À retenir
Dépendance Maven
spring-boot-starter-validation
Annotations de validation (exemples)
@NotNull
@Size(min=3, max=50)
@DecimalMin("0.01") (prix > 0)
@DecimalMin("0") (quantité >= 0)
8-validation-memo.md 2026-01-27
2 / 2
Remarque : selon vos types (double, int), @NotNull n’a d’effet que sur les types objets (Double,
Integer).
Contrôleur : @Valid + BindingResult
Signature typique :
public String produitSave(..., @Valid Produit produit, BindingResult
bindingResult, ...)
Tester :
if (bindingResult.hasErrors()) return "produitEdit";
Thymeleaf : affichage d’erreurs
Champ avec style erreur :
th:class="${#fields.hasErrors('designation')} ? 'form-control is-invalid' :
'form-control'"
Message d’erreur :
<div th:errors="*{designation}" class="invalid-feedback"></div>
Pièges fréquents
BindingResult doit être juste après le paramètre @Valid Produit.
Si on retourne produitEdit en cas d’erreur :
ne pas oublier de remettre p, s, mc dans le Model (sinon on perd le contexte).

10 - REST (Spring Data REST + RestController)
Étapes réalisées
1) Création du projet Spring Boot REST
1. Générer le projet (Spring Initializr) : Maven + Java 17/21 + Spring Boot 3.4.
2. Dépendances :
Spring Web
Spring Data JPA
Spring Data REST
MariaDB Driver
Lombok
(option) Thymeleaf
2) Configuration MariaDB
1. Créer une base dédiée : springrest_produits.
2. Configurer src/main/resources/application.properties :
server.port=8088
spring.datasource.*
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
3) Entité Produit (JPA + Lombok)
1. Créer entities/Produit.
2. Annotations JPA : @Entity, @Id, @GeneratedValue(...).
3. Annotations Lombok : @Data, @NoArgsConstructor, @AllArgsConstructor.
4) Repository ProduitRepository
1. Créer dao/ProduitRepository extends JpaRepository<Produit, Long>.
2. Ajouter @RepositoryRestResource pour exposer automatiquement en REST.
5) Initialiser des données (CommandLineRunner)
1. Implémenter CommandLineRunner (ou @Bean CommandLineRunner) dans la classe principale.
2. Insérer des produits via produitRepository.save(...).
6) Tester l’API auto-générée (Spring Data REST)
Base : http://localhost:8088/produits
Tester avec Postman :
GET /produits
POST /produits (JSON)
DELETE /produits/{id}
10-rest-memo.md 2026-01-27
2 / 3
Pagination : /produits?page=0&size=2
7) Ajouter une recherche personnalisée (endpoint /search)
1. Dans le repository, ajouter une méthode findByDesignationContaining(...).
2. Exposer la recherche avec :
@RestResource(path = "byDesignation")
@Param("mc")
3. Tester :
GET /produits/search/byDesignation?mc=SSD
8) Créer un contrôleur REST personnalisé (option “plus de contrôle”)
1. Créer ProduitRestController.
2. Endpoints :
GET /api/produits → liste
POST /api/produits → ajout (@RequestBody)
DELETE /api/produits/{id} → suppression (@PathVariable)
À retenir
Ports / URLs
App : server.port=8088
Spring Data REST : /produits
Recherche : /produits/search/...
Controller personnalisé : /api/produits
SQL / DB
CREATE DATABASE springrest_produits;
JDBC typique : jdbc:mariadb://localhost:3306/springrest_produits
Annotations clés
JPA
@Entity, @Id, @GeneratedValue(strategy = GenerationType.IDENTITY)
Lombok
@Data (getters/setters + toString + equals/hashCode)
@NoArgsConstructor, @AllArgsConstructor
Spring Data REST
@RepositoryRestResource
@RestResource(path = "...")
@Param("...")
10-rest-memo.md 2026-01-27
3 / 3
Controller REST
@RestController
@RequestMapping("/api/produits")
@GetMapping, @PostMapping, @DeleteMapping("/{id}")
@RequestBody, @PathVariable
Requêtes Postman (exemples)
POST /produits (Spring Data REST) :
{ "designation": "Clavier", "prix": 100.0, "quantite": 15 }
Pièges fréquents
Lombok : installer l’extension VSCode + activer l’annotation processing si besoin.
Spring Data REST expose des endpoints automatiquement : attention à bien distinguer /produits et
/api/produits.
ddl-auto=update pratique pour le TD, mais pas recommandé tel quel en prod.